-- Migration to create the offers table and related functionality (making it safe to rerun)

-- 1. Create the offer_status enum type IF NOT EXISTS
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'offer_status') THEN
        CREATE TYPE public.offer_status AS ENUM ('pending', 'accepted', 'rejected');
    END IF;
END$$;

-- 2. Create the offers table IF NOT EXISTS
create table if not exists public.offers (
    id bigint generated by default as identity primary key,
    auction_id bigint not null references public.auctions(id) on delete cascade,
    user_id uuid not null references auth.users(id) on delete cascade,
    amount numeric not null check (amount > 0),
    status public.offer_status not null default 'pending',
    created_at timestamp with time zone not null default now(),
    updated_at timestamp with time zone not null default now()
);

-- Add Indexes IF NOT EXISTS
CREATE INDEX IF NOT EXISTS idx_offers_auction_id ON public.offers(auction_id);
CREATE INDEX IF NOT EXISTS idx_offers_user_id ON public.offers(user_id);
CREATE INDEX IF NOT EXISTS idx_offers_status ON public.offers(status);

-- 3. Create helper function for check constraint (COMMENTED OUT)
/*
CREATE OR REPLACE FUNCTION public.is_offer_type_auction(p_auction_id bigint)
RETURNS boolean
LANGUAGE sql
STABLE
AS $$
    SELECT EXISTS (
        SELECT 1
        FROM public.auctions a
        WHERE a.id = p_auction_id AND a.listing_type = 'offer'
    );
$$;

-- Grant execute on the helper function (COMMENTED OUT)
GRANT EXECUTE ON FUNCTION public.is_offer_type_auction(bigint) TO postgres, authenticated, service_role;
*/

-- Add constraint: Ensure offers are only for 'offer' type listings IF NOT EXISTS, using the function (COMMENTED OUT)
/*
DO $$BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.table_constraints 
        WHERE constraint_name='check_offer_listing_type' AND table_name='offers' AND table_schema='public'
    ) THEN
        ALTER TABLE public.offers
        ADD CONSTRAINT check_offer_listing_type
        CHECK (public.is_offer_type_auction(auction_id));
    END IF;
END$$;
*/

-- 4. Add constraint: Ensure only one pending offer per user per auction IF NOT EXISTS
DO $$BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_indexes 
        WHERE indexname = 'unique_pending_offer_per_user_auction' AND schemaname = 'public'
    ) THEN
        CREATE UNIQUE INDEX unique_pending_offer_per_user_auction
        ON public.offers (auction_id, user_id)
        WHERE (status = 'pending');
    END IF;
END$$;


-- 5. Set up Row Level Security (RLS)
-- Enable RLS (safe to run multiple times)
alter table public.offers enable row level security;

-- Helper function to check if the current user is an admin (create or replace is safe)
create or replace function public.is_admin()
returns boolean
language sql
security definer
set search_path = public
as $$
    select exists (
        select 1
        from public.profiles
        where id = auth.uid() and role = 'admin'
    );
$$;

-- Policies using DROP IF EXISTS / CREATE
DROP POLICY IF EXISTS "Allow users to insert their own offers" ON public.offers;
CREATE POLICY "Allow users to insert their own offers"
ON public.offers FOR INSERT
WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Allow users to select their own offers" ON public.offers;
CREATE POLICY "Allow users to select their own offers"
ON public.offers FOR SELECT
USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Allow admins to select all offers" ON public.offers;
CREATE POLICY "Allow admins to select all offers"
ON public.offers FOR SELECT
USING (is_admin());

DROP POLICY IF EXISTS "Allow admins to update offer status" ON public.offers;
CREATE POLICY "Allow admins to update offer status"
ON public.offers FOR UPDATE
USING (is_admin())
WITH CHECK (is_admin());

-- 6. Trigger function to update updated_at timestamp (create or replace is safe)
create or replace function public.handle_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql security definer;

-- Trigger to update updated_at on offers table modification (DROP/CREATE)
DROP TRIGGER IF EXISTS on_offers_update ON public.offers;
CREATE TRIGGER on_offers_update
  BEFORE UPDATE ON public.offers
  FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();

-- Grant usage on the new enum type
grant usage on type public.offer_status to postgres, anon, authenticated, service_role;

-- Grant permissions on the new table
grant select, insert, update, delete on table public.offers to postgres;
grant select, insert on table public.offers to authenticated;
grant select, update on table public.offers to service_role; 
revoke select on table public.offers from anon;

-- Grant execute on admin check function
grant execute on function public.is_admin() to postgres, authenticated, service_role; 